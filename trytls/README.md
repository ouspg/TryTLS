# trytls runner

## Exit codes

This runner exits with a non-zero exit code when there is at least one FAIL or ERROR result. This feature is useful e.g. when using the trytls tool as a part of a Continuous Integration setup.

The specific exit code in such situations is 3, to distinguish it from some other common situations: The CPython interpreter exits with 1 when an unhandled exception occurs, and with 2 when there is a problem with a command line parameter (see Py_Main which CPython's main uses in versions 2.7 and 3.5). The argparse module also uses the code 2 for the same purpose.

## Helpers for Local Testing

Add helpers for writing local test servers: `trytls.testenv.local(ok_expected, cn, [callback=...])` launches a simple temporary TLS server on `localhost` (with keys generated by `gencert`).  After the test has been completed the temporary TLS server gets shut down.

  * `ok_expected` tells whether the connected clients should be able to verify the server certificate.

  * `cn` tells the Common Name that should be passed to `gencert` when generating the server certificates.

  * The optional `callback` argument can be passed in to modify how a created connection socket is used after a socket connection has been established. The default callback just does the TLS handshake, but is also used by the HTTPS bundle (described later) to imitate a webserver. For an example see bundles/https.py

## Test Bundles

Add the concept of *test bundles* and add a command line option `-t`/`--test-bundle` to the `trytls` tool for configuring the used test bundle.

A test bundle is a bundle of tests specialized for some protocol/situation ("just a plain TLS handshake", "a HTTPS server", ...). In practice a test bundle is just a named list of tests to be run. As an example see bundles/handshake.py (described later).

The command line parameter `-t` (or `--test-bundle`) is used to tell which test suite should be run. The value should be an absolute Python import path, for example `trytls.bundles.https.all_tests` for importing the test list `all_tests` from the `trytls.bundles.https` module. For convenience the path can also be a relative one (i.e. starting with `.`) in which case the bundle is imported under the `trytls.bundles` package meant for built-in bundles. Therefore `trytls.bundles.handshake.all_tests` can be referred to as `.handshake.all_tests`.

The default `--test-bundle` value is `.handshake.all_tests`.

The support for absolute import paths is there because that allows people to write their own test bundles that don't have to be a part of the `trytls` package. This in turn makes it easier to host the bundle code somewhere else than this repository.

### Built-in Bundles

  * `.handshake.all_tests`/`trytls.bundles.handshake.all_tests` for testing plain TLS handshakes (on a local server and on the BadSSL servers). This is the default test bundle for the `trytls` tool.

  * `.https.all_tests`/`trytls.bundles.https.all_tests` that is pretty much like the `.handshake` bundle but also sends a rudimentary HTTP response back to the client. Should help in testing HTTP clients.

  * `.imap.all_tests`/`trytls.bundles.imap.all_tests` that currently just tells to connect to Gmail's IMAP servers.

### Example

Testing the `examples/python3-urllib/run.py` stub against only the local tests in the builtin HTTPS bundle:

```console
$ trytls -t .https.local_tests python3 stubs/python3-urllib/run.py
```

## On-the-fly Certificate Generation

Added `trytls.gencert.gencert(cn="...")` for generating a PEM encoded server certificate + private key pair and a PEM ca bundle against which the server certificate verifies. The function basically just wraps the `openssl` command and generates a server certificate for the given Common Name. To save time the private server key and the private CA key are generated once per process.

As an example you can generate `cert.pem`, `cert.key` and `ca.pem` like this:
  ```python
from trytls.gencert import gencert


def writefile(filename, data):
    with open(filename, "wb") as f:
        f.write(data)


cert, key, ca = gencert("localhost")
writefile("cert.pem", cert)
writefile("cert.key", key)
writefile("ca.pem", ca)
```
Now launching a HTTP server on localhost with the `cert.pem` and `cert.key` files allows clients to create a verified connection to it using the `ca.pem` CA file.
